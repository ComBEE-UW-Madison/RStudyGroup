---
title: "Working with Data in R"
author: "Brian S. Yandell"
date: "6/29/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "")
```

## Data Structures in R

There are many good introductions to data structures in `R`.
Basically, `R` can act as a calculator, and has built in functions such as `log(10)` and `sqrt(4)`,
but can do so much more. See examples in the links below.

The basic structure in `R` is a vector, here is a vector of the numbers 1 through 5:

```{r}
1:5
```

> ## Challenge
>
> Go through the Data Carpentry or Jenny Bryan introduction to learn more about data basics.
> Read through Doub Bates notes to fill in further gaps.

- [R Introduction from Data Carpentry](http://kbroman.org/datacarpentry_R_2017-01-10/01-intro-to-R.html)
- [R basics from Jenny Bryan](http://stat545.com/block002_hello-r-workspace-wd-project.html)
- [Data frames, examining structure from Doug Bates](https://github.com/dmbates/stat692/blob/master/Data.Rmd)

## Data Wrangling

It is often more useful to think of `R` as mostly operating on rectangular tables, which have many of the characteristics of spreadsheets. Tables, known in `R` as data frames, have observations (individuals or cases) in rows and variables (fields) in columns. The variables might be of different types, say numeric or character or logical. We might want to operate on the whole table, or on a row or column, or on some rectangular subset of the table.

The [tidyverse](http://tidyverse.org) provides a useful set of tools to organize work around tables. See the [tidyverse style guide](http://style.tidyverse.org/) for detail. See also the data pages from various sources:

- [Introduction to the Tidyverse (nee Hadleyverse) (Doug Bates)](https://github.com/dmbates/stat692/blob/master/Hadleyverse.Rmd)
- [Aggregating and analyzing data with dplyr (Data Carpentry)](http://kbroman.org/datacarpentry_R_2017-01-10/02-dplyr.html)
- [Data analysis 1 (Jenny Bryan)](http://stat545.com/topics.html) (see links under this topic)

Right here would like to go through an example using loops, then `apply` suite, then `dplyr` and `tidyr`, then `purrr`. The point would be that while the old way gets the job done, the newer tidyverse provides more compact ways of organizing the task that are more intuitive, once one overcomes the new way of thinking about the problem. 

Here is the basic idea. It might seem best to go a row and column at a time and do operations, but if we can think about the whole object, the entire table, and what we want to do with it, then a more elegant solution might emerge.

### dplyr

The `dplyr` package allows us to filter by rows and select columns, and to do tasks in groups organized by levels of columns. Further, these steps can be strung together using `pipes` as a coherent operation on a table, to create a new table. This new table may be stored, or might be used in another operation without ever being saved as a new object. See notes linked above.

The latest release of `dplyr` (0.7.0) in its basic form appears unchanged. However, there is a new philosophy of "tidy evaluation" that will have a profound effect on how we use `dplyr` tools within functional programming. That is, the straightforward way to use `dplyr` is to reference table columns by name, which works great in an interactive setting. If the column names might change from table to table, and you want to create tools that leverage that, it will be important to learn about tidy evaluation.

- [dplyr 0.7.0 release announcement](https://blog.rstudio.org/2017/06/13/dplyr-0-7-0/)
- [tidy evaluation](http://rlang.tidyverse.org/articles/tidy-evaluation.html)
- [RStudio Webinars](https://www.rstudio.com/resources/webinars/) (see What's new in dplyr 0.7.0?)

### tidyr

### purrr

- [Iteration chapter of R for Data Science](http://r4ds.had.co.nz/iteration.html)
- [Solving iteration problems using functional programming](https://www.rstudio.com/resources/videos/happy-r-users-purrr-tutorial/)

## Working with strings

Sometimes one may want to change names of columns in a table. Here is what might seem like a logical approach, but it is in fact difficult to read, awkward and repetitive, and slow.

```
new_names=list()
l=1
for(n in colnames(x)){
      ifelse((l<10), (colnames(x)[l]=c(paste0('Otu000',c(l)))), (colnames(x)[l]=c(paste0('Otu00',c(l))))) 
      new_names=append(new_names, colnames(x)[l])
      l=l+1
}
```

Here is an improved 
```
new_names <- paste0("Otu", stringr::str_pad(seq_along(colnames(x)), 4, pad="0"))
```

## Reading and writing tables

- read.csv and readr::read_csv
- write.csv and write::write_csv
- readxl::read_excel

## Everything in R is a vector

If you are new to programming, this subsection might be skipped. Experienced programmers who are new to `R` might find this useful. The basic argument: everything in R is a vector (no scalars!).

Atomic vectors include integers, double-precision, strings (character), logical, raw and a few others. 

```{r}
(v <- 1:6)
```

A list is a vector of objects that donâ€™t have to share relationships (but can).
Here we do something silly, turning a vector of six numbers into a list, which is a vector of six objects, each of which is a vector with one number.


```{r}
(as.list(v <- 1:6))
```

### Attributes

Attributes can be attached to objects

```{r}
v <- 1:6
attributes(v) <- list(message = "hello world")
v
```

Attributes can turn a vector into a matrix

```{r}
v <- 1:6
attributes(v) <- list(dim= c(3,2))
v
```

This is equivalent to

```{r}
(x <- matrix(1:6, ncol=2))
```

Note that while `v` (and `x`) is a matrix, it is still a vector of six numbers:

```{r}
attributes(v)
```

```{r}
length(v)
```

```{r}
v[4]
```

A matrix can be turned into a data frame:

```{r}
(x <- as.data.frame(x))
```

Now `x` as a data frame is a vector (actually a list) of length 2, with each element of the list being a vector of numbers:

```{r}
x[[2]]
```

### Subsetting and Accessing

Subset using positive integers:

```{r}
v[c(3,4,6,6)]
```

```{r}
v[1:3]
```

Subset using logical

```{r}
v[c(FALSE, FALSE, TRUE)]
```

This takes some explaining, the vector `c(FALSE, FALSE, TRUE)` is cycled through the indices of `v` (here `1:6`). Try this one:

```{r}
v[c(TRUE, TRUE, FALSE, FALSE)]
```

Logical with normal dist example:

```{r}
(r <- rnorm(6, 0, 1))
v[r>0]
```

```{r}
(r <- rnorm(15, 0, 1))
v[r>0]
```

Notice that in this case some of the indices are beyond the data and return missing values.

Use negative numbers to exclude some indices. You cannot mix positive and negative numbers.

```{r}
v[-(1:3)]
```

Zero (0) is skipped. Works with positive or negative numbers. This is useful for instance with the `match()` function if you set `nomatch = 0`.

```{r}
v[c(0,2,4)]
```


```{r}
v[c(0,-2,-4)]
```

```{r}
v[0]
```

Note that if all indices to a vector are 0, then a vector of length 0 is returned. This also happens with `NULL`:

```{r}
v[NULL]
```


```{r}
(r <- sample(letters, 15))
(m <- match(c("a","c","e"), r, nomatch = 0))
v[m]
```

Elements of a vector can be identified by name

```{r}
v <- c(v)
names(v) <- letters[seq_along(v)]
v
```

```{r}
v["c"]
```

For lists, you can use `[[]]` or `$`. Double brackets (special for lists) pull out components; `$` is a shorthand that works for proper names.

```{r}
l <- as.list(v)
(l[["c"]])
(l$c)
```

We saw recycling of logical indices above. Here is another form of recycling:


```{r}
v + c(1,2)
```

will return 2, 4, 4, 6, 6, etc.

See also

- [Data analysis 2: vectors and files](http://stat545.com/topics.html) (scroll down to this topic)

